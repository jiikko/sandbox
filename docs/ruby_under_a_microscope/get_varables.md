# Rubyのレキシカルスコープの実装

*  Rubyは変数に保存した値すべてを、YAVM命令列の引数や返り値と一緒にyarvスタック上に格納する。
  * しかし、これらの変数へのアクセスはそう単純ではない。
* 変数にあたいを保存したり、変数から値を読みだしたりスルタメニmRubyローカル変数アクセスと動的変数アクセスとおおいう2つのまったくことなる方法を元いている。

# ローカル変数アクセス
* メソッド呼び出しを行った際、Rubyは呼び出したメソッド内で宣言されたローカル変数用のスペースをyarvスタック上にいくつか追加する。
  * ローカルテーブルは、コンパイラの段階で書くメソッドに対して作成されたローカルテーブルを参照することによって、Rubyはいくつかの変数が使われているかを把握している。
* 例えば、以下のように無駄にローカル変数を使う関数を記述したたとする。

```ruby
def display
  str = "hello"
  puts str
end
```

図の左側がRubyコード、図の右側が

| (blank) |
| ------------- |
|  |
|  |
|  |


---


```ruby
def display
  str = "hello"
  puts str
end
```
だとYARVスタックは次のようになる。

```
__________
|           |
|           |
|           |  <= SP
| special   |  <= EP
| svar/cref |
| str       |
```

* Rubyがスタックポインタのすぐ下でスタック上に変数をを保存していることがわかる。(スタック-3にstrを格納している)
* 特殊変数のテーブルへのポインタか、現在のレキシカルスコープへのポインタのいずれかを`svar/cref`に含める。ここでいうレキシカルスコープとは、メソッドが追加sれたクラスかモジュールのことを示している。
* rubyはブロックに関連する情報を記録するのに最初のスロット、special変数を使う。(詳細は動的変数アクセスを説明する際に述べる。)
* これを内部て錦衣実装するためにyarvはスタックポインタと同じようにな別のポインタを使用する。これはEP, environment pointer と呼ばれる。
* このポインタは現在のメソッド用のローカル変数がスタック上のどこにあるかを示す。
* 最初のEPは、SP-1に設定される。そのあと、SPの値がyarvが命令を実行することによって変更しても、EPの値は変わらずにそこにとどまる。
