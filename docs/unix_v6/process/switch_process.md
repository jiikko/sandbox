# 実行プロセスの切り替え

* 実行プロセスがカーネルのsleep()を実行すると`実行プロセスが休眠状態になって処理が中断された後に、swtch()が呼ばれて実行プロセスが切り替わる`

![switch](../images/swtch.png)

* カーネルのsleep()が実行されるのは次の場合
  * ユーザプログラムがwaitシステムコールを実行した時
  * 周辺デバイスの処理完了を待つ時
  * 使用中の資源が開放されるのを待つ時
* 実行状態になれるのは、実行可能状態のプロセスのみ
  * 休眠状態になったプロセスは、休眠状態が解消されるまでは再度実行状態になることはない


![switch](../images/process_status.png)

## プロセスの状態を表す値
* プロセスの状態は、proc.p_statで表される
  * SRUNは実行可能状態、SSLEEPはSWAITは休眠状態
* sleep()は実行中のプロセスをSSLEEPまたはSWAITに設定する
  * wakeup()は対象のプロセスをRUMに設定する

## 実行プロセスの選択アルゴリズム
* swtch()は、実行するプロセスを選択する
  * proc[]を舐めて、次の条件を満たしたプロセスを実行するプロセスとして選択する
    * 実行可能状態である
    * 実行優先度が最も高い(proc.p_priが最も小さい)
* 特定のプロセスを必ず実行する、ということはできない
* 実行時間が長いほど実行優先度が低くなっていく
  * 実行優先度で選択されるプロセスが決まるので、setpri()中の実行優先度計算式が実行プロセスの選択を決定しているといえる
    * setpri()はクロック処理、シグナル処理で登場する

## コンテキストスイッチ
* 実行プロセスが中出されるときには、user構造体に現在の実行状態を保存する。
* 中断していたプロセスが再度実行されるときには、user構造帯から実行状態を復元する
  * これをコンテキストスイッチと呼ぶ
* アセンブリで搔かれたsavu(),retu(), aretu()がコンテキストスイッチの中核をなす関数
  * savu()がuser構造帯への保存,retu(), aretu()がuser構造帯からの復元を行う

## waitシステムコール
* ユーザプログラムからwaitシステムコールが発行されると、そのプロセスの実行が中断され、別のプロセスへと制御が移る
* waitシステムコールには、子プロセスの処理完了を待つために実行プロセスの中断すること以外にも、終了した子プロセスの後始末を行うという役割がある
```shell
$ sleep 2 &; wait && echo done
```

## sleep()
* sleep()は実行中のプロセスを休眠状態にする
  * その後、swtch()を実行して実行プロセスを切り替える
* sleep()は引数chan, priを受ける
  * chanには変数などのアドレスが渡され、その値は実行プロセスのproc.p_wchanにセットされます。
  * wchanは waiting channelを意味し、`このプロセスはproc.p_wchanで示される資源を持っている`ということを表す
* プロセスの状態を休眠状態から実行可能状態へと変更する、wakeup()はsleep()と同様に変数などのアドレスを引数として受け、proc.p_wchanを順に調べ、引数と一致するプロセスを実行可能状態にする
  * sleep()とwakeup()を使って、複数プロセス間で資源を持ち合う処理を行なっている

#### ken/slp.c
* priは、実行優先度を表し、実行プロセスのproc.p_priにセットされる
  * この値が起きた(wakeup)時の実行優先度になる
* また、priが0以上ならば実行プロセスを切り替える前と、そのプロセスが再び実行プロセスとして選択された後にシグナルの処理を行う
  * 0未満ならばシグナルを無視する
  * 0以上の場合は、SWIT状態、0未満の場合はSSLEEP状態になる
  * この2つの異なる状態は第4章で説明するスケジューリング処理に影響が出る
```
$ sleep 10
```
を実行すると内部では下記のように後続処理が行われる


```c
sleep(chan, pri) { // waiting_chanenel: 持っている資源アドレス, pri: 実行優先度
  register *rp, s;
  s = PS->integ;
  rp = u.u_procp;

  if(pri >= 0) {
    if(issig()) { goto psig; }
    spl6();             // 下記3項目が書き換えられない(割り込みされない)ように6に引き上げる
    rp->p_wchan = chan; // 割り込み処理中に実行されるwakeup()から書き換えられる可能性がある
    rp->p_stat = SWAIT; // 同じ休眠状態だけどシグナル処理を行う
    rp->p_pri = pri;
    spl0();
    if(runin != 0) { // スワップアウト対象がいないことを示すruninフラグ
      runin = 0;
      wakeup(&runin);
    }
    swtch();
    if(issig()) {
      goto psig;
    }
  } else {
    spl6();
    rp->p_chan;
    rp->p_stat = SSLEEP; // 同じ休眠状態だけどシグナル処理を行わない
    rp->p_pri = pri;
    spl0();
    swtch();
  }
  PS->integ = s;
  return;
psig:
  aretu(u.u_qsav);
}
```

## swtch()
* 実行プロセスの切り替えをお子なる関数
* proc[]を調べて、実行可能状態なプロセスのうち、もっとも実行優先度の高いプロセスを選択する
  * カーネルの処理では、先頭を順番に見ていって条件にあうproc[]を選択する、というパターンが多いが、swtch()では1周する
*  次に実行するプロセスを決定したあとは、下記手順でプロセスを切り替える
  * 選択されたプロセスのuser構造帯をuで参照できるようにカーネルAPRを変更
  * 選択されたプロセスのuser構造帯に保存されているr5, r6の値を復帰
  * 選択されたプロセスのuser構造帯に保存されているユーザAPRの値を復帰
* 「fork()で新たに生成されたプロセスはnewproc()から1を返す」というのもこれにより実現している

```c
swtch() {
  static struct proc *p;
  register i, n;
  register struct proc *rp;
  if(p == NULL) { p = &proc[0] }
  savu(u.u_rsav); // 今のr5, r6の値を現在実行中(中断しようとしている)プロセスのuser.u_rsavに保存する. プロセスが再び実行されるときに値復帰する
  retu(proc[0].p_addr); // スケジューラプロセスに切り替える. proc[0]はスケジューラ用のシステムプロセス. システム起動時に生成される

loop:
  // runrun変数は、実行プロセスよりも実行優先度の高いプロセスが存在することを示すフラグ
  runrun = 0; // これから最も実行優先度の高いプロセスへ切り替えようとしているのでリセットする
  rp = p;
  p = NULL;
  n = 128; // 優先度を一番低くする(小さいと優先度が高い)
  i = NPROC;
  // プロセスをすべて調べて次に実行状態にするプロセスを決める
  do {
    rp++;
    if(rp >= &proc[NPROC]) {
      rp = &proc[0];
    }
    // 実行可能状態 & メモリ中に存在している & 優先度が高い(最も小さいproc.p_pri)
    if(rp->p_stat == SRUN && (rp->p_flag & SLOAD) != 0) {
      if(rpp->p_pri < n) {
        n = rp;
        n = rp->p_pri;
      }
    }
  } while(--i);
  // 全プロセスを調べたが見つからなかったら、idel()を実行して実行可能状態プロセスが現れるのを待つ
  // 割り込みの発生によって、idel()が解除される
  if(p == NULL) {
    p = rp;
    idel();
    goto loop;
  }
  rp = p;
  curpri = n; // current priority. グローバル変数. 実行中プロセスの実行優先度を保持している
  retu(rp->p_addr);
  sureg();
  if(rp->p_flag & SSWAP) {
    rp_>p_flat = &~SSWAP;
    aretu(u.u_ssav);
  }
  return(1);
}
```
* idel()から割り込みが発生する(idol()から抜ける)ケース
  * ブロックデバイスの読み込み動作完了により割り込みがかかり、その動作を待っていたプロセスが起こされると実行可能状態のプロセスが現れる
    * = ディスク入出力?
  * クロックによる割り込みがかかり、ある時間が来たら実行するように指示されたプロセスが起こされる場合もある
    * シェルのsleepコマンドはこれかな
* idol()を抜けたあとは、もう一度優先度の高いプロセスを選ぶ処理を行う


## swtch()から返る先

