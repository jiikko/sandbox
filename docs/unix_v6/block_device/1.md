# でロックデバイスサブシステム
## デバイスの種類
* ブロックデバイス
   * 処理単位はブロック単位
   * 高速
   * 先頭ブロックから順に0, 1, 2...とアドレスが振られている
   * 大量データ転送に向いている
     * カーネルのバッファの使用により、キャッシュ、非同期操作、遅延書き込みなどをサポートする
     * ブロックでバイス上にファイルシステムが構築される
   * ディスクデバイス
* キャラクタデバイス
  * 処理端は文字
  * アドレスは振られてなくてデータは使い捨て
  * キューの先頭からしかアクセスできない(シーケンシャルアクセス)
  * 低速
  * 少量データ転送に向いている
  * ラインプリンタ、制御端末

# デバイスドライバ
* デバイスドライバは、デバイスの操作を行うプログラム
  * 1デバイスに対して、1デバイスドライバがあることが普通
* デバイスドライバは、デバイスドライバテーブルで管理されてる

# クラスとデバイス番号

# スペシャルファイル
* あるデバイスを使用するためには、そのデバイスに対応するスペシャルファイルを作成する必要があります。
  * システムの管理者がユーザプログラムの/etc/mknodを実行して、スペシャルファイルを作成します。
  * スペシャルファイルにはデバイスのクラスとデバイス番号が含まれる
* スペシャルファイルは/devの下に作成し、そのデバイスを表す文字列とマイナー番号を組み合わせた名前にします
  * たとえば/dev/rk0 というようにします
* /etc/mknod が成功すると、指定されたディレクトリにスペシャルファイルが追加され、それに他王したinodeが作成される
  * inodeにはクラスを表すフラグが立ち、inode.i_addr[0]にはデバイス番号が格納される
* そのスペシャルファイルに対して、open, read, write, closeシステムコールが実行することで、
  * システムコールハンドラ内でメジャー番号に対応したデバイスドライバが呼び出され、デバイスの操作が行われる
* ユーザから見ると通常ファイル操作とデバイス操作のインターフェースが共通になっているので、
  * たとえばユーザプログラムの出力をファイルからラインプリンタに変えたいときにはopenする対象を切り替えるだけですむ
  * 通常ファイルとデバイスのインタフェースが統一されているのはUNIX V6特徴

## バッファ
* ブロックデバイスサブシステムは、バッファを用いてブロックデバイスとデータのやりとりを行う
* バッファには、デバイス番号とブロック番号で名前をつける
  * あるブロックに対する操作を行うときには、必要としているバッファすでにないか探し、見つかればそれを使用する
  * 見つからなければ、新たに未割当バッファを取得し、それに名前をつけて使用する
* バッファを用いる目的は、大きく2つある
  * 1つめは、複数のプロセスから同時に同じブロクのアクセスが起きた時に整合性を保つため
  * 2つめは、よく読み書きするブロックのコピーをメモリ中におくことで性能を改善するためです
  * キャッシュをつけってブロックデバイスへのアクセス回数を減らせる
  * ブロックデバイスへのアクセス速度はCPUと比べて遅いのでアクセス回数が減ればシステムの性能改善が見込める
  * 他にも、必要となるデータを裏でさきにバッファに読み込んでおいたり、バッファにデータ満たされてから初めてブロックデバイスにデータを書き込みに行くなどすると性能改善する
* バッファは、buf構造体の配列buf[]で管理されている

## b-list と ac-list
* buf[]はb-listとav-listの二重リンクリストで管理されている
* なぞ

## RAW入出力
* ブロックデバイスに対しバッファを経由せず、かつ、ブロックサイズ(512バイト)の制限を受けないデータ転送を行うことができる
  * これをRAW(無処理)入出力とよぶ。
  * ブロックデバイスのデータをまるごとコピーしてバックアップを取る時などに使用する
* 通常入出力の場合は、バッファを経由して仮想アドレス空間とデータ転送を行う
  * RAW入出力の場合、バッファを介せず直接データの転送を行う
* システムの管理者はRAW入出力のために、専用のスペシャルファイルを作成する. キャラクタデバイスとしてスペシャルファイルを作成し、キャラクタデバイスドライバテーブルを登録する

## 読み込み
### 同期読み込み
* getblk()でバッファを取得したあとに、ブロックデバイスに対して読み出し要求を行ない、iowait()を実行してスリープする
  * sleepすると別プロセスが割り込みを待ち、割り込みが走るとそのあとにiodoneで起こす
* ブロックデバイスの動作が完了すると、割り込みハンドラが実行するiodone()により起こされる
  * sleepから復帰するとバッファにアクセスしてデータを読みだす
* その後、brelse()でバッファを自分で解放する

図

### 非同期読み込み
* ブロックデバイスの読み込み動作が完了するのを待たずに処理を続ける
  * バッファは割り込みハンドラが実行するiodone()により自動的に開放される
  * バッファにB_ASYNCフラグを立てると非同期読み込みになる
* 非同期読み込みは、先読みに使用される。
  * 先読みはあるファイルのブロックを順に読んでいる時に、次のブロックのデータを予めバッファに呼び出しておく機能

図

## 書き込み
### 同期書き込み
デバイスの処理完了を待つ

### 非同期書き込み
デバイスの処理完了を待たない

### 遅延書き込み
* 遅延書き込みした直後は書き込み処理は行われずバッファにB_DELWRIフラグを立てておき、別のプロセスがブロックの読み込みした時に、先ほど遅延書き込み分をデバイスに書き込む
* B_DEOWRIフラグが立てられたバッファはバッファのフラッシュを行うbflush()が実行された時にもデバイスにたいして書き込みを行う

## ついで
* ブロッキングIO
  * 同期と同じで待つ
  * 複数接続をもてない
* ノンブロッキングIO
  * 非同期と違ってシグナルとか通知がこないので完了したのかのポーリングする
  * 複数接続をもてる
* IO多重化
  * 複数のfdを引数に渡して完了したioがあれば返ってくる. ないなら待つ
  * 複数接続をもてる
